= Vagrant, Amazon EC2, Docker and Microservices pt1.
Sion Williams
2015-03-09
:jbake-type: post
:jbake-status: published
:jbake-tags: vagrant, ec2, aws, docker, microservice, gradle

== Introduction

Microservices are all the rage at the moment, but from my experience they just move the bottleneck. Yes, the speed of development increases massively, but it does so at the cost of an increased dependency on the Build and Ops guys.

This blog series is about using Docker to run a complete and fully functional microservice in the cloud using Vagrant, Amazon AWS and Docker. The goals are as follows:

* Provisioning of the EC2 instance should be automated
* The microservices should run in their own containers
* The setup and configuration of the containers should be fully automated, no manual steps required
* Capture everything in a GitHub project.

== Vagrant

Vagrant is a nice way to manage our EC2 instances. We can use Vagrant to create and instance and provision the box to a state we desire.

Once Vagrant is installed on your dev machine, to use the `AWS` provider type in Vagrant we will need to install the Vagrant AWS plugin. That can be done with the following command:

`vagrant plugin install vagrant-aws`

NOTE: This took a while on my machine without a great deal of feedback. Just be patient, it will finish eventually.

So, now lets create our project and the Vagrantfile. Run the following commands:

[source, bash]
----
# create a project folder
$ mkdir infra-n-app-automation

# change directory
$ cd infra-n-app-automation

# create the vagrant file
$ vagrant init
----

You should get a message something similar to:

[source]
----
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
----

If we follow the Vagrant AWS plugin docs, we can see the basic Vagrantfile should look as follows:

[source, ruby]
----
Vagrant.configure("2") do |config|
  config.vm.box = "dummy"

  config.vm.provider :aws do |aws, override|
    aws.access_key_id = "YOUR KEY"
    aws.secret_access_key = "YOUR SECRET KEY"
    aws.session_token = "SESSION TOKEN"
    aws.keypair_name = "KEYPAIR NAME"

    aws.ami = "ami-7747d01e"

    override.ssh.username = "ubuntu"
    override.ssh.private_key_path = "PATH TO YOUR PRIVATE KEY"
  end
end
----

The guide suggests putting your +access_key_id+ and +secret_access_key+ in the Vagrantfile, which is fine if you have a private repository, but as I plan on making this public I will set them using environment variables.

[source, bash]
----
export AWS_ACCESS_KEY="AKXXXXXXXXXXXXXXX"
export AWS_SECRET_KEY="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
----

After configuring my Security Group, selecting an AMI and sorting my private key, my Vagrantfile now looks like:

[source, ruby]
----
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(2) do |config|
  # Box configuration
  config.vm.box = "dummy"
  config.vm.box_url = "https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box"

  # Share an additional folder to the guest VM.
  # config.vm.synced_folder "../data", "/vagrant_data"

  # Provider
  config.vm.provider :aws do |aws, override|
    aws.keypair_name = "dev"
    override.ssh.username = "ubuntu"
    override.ssh.private_key_path = "~/.ssh/dev.pem"

    aws.ami = "ami-234ecc54" #Ubuntu 12.04 LTS
    aws.region = "eu-west-1"
    aws.instance_type = "t2.micro"
    aws.security_groups = ["WebServerSG"]

    aws.tags = {
      'Name' => 'Vagrant'
    }
  end

  # Provisioning
end
----


=== Gotchas

I had a few challenges when I first started with Vagrant and AWS. They were:

* *Security Groups* - You will noticed I used the +WebServerSG+ group. I set this up as per the Amazon documentation found http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario3.html#SecurityGroups-3[here]. Until I made this change I was hanging at the "_Waiting for SSH to become available..._" stage.
* *AMI* - If you want to use the free tier I would recommend going through the Amazon "Launch Instance" wizard and recording the AMI id for your region and price plan. I found some of the online examples simply didn't exist and were region specific.

== Conclusion

This concludes part one of the tutorial. We can now create and control the lifecycle of an EC2 instance, and in part two we will install Docker and any other dependencies on the instance.

The source can be found in the repository below:

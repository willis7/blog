<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://willis7.github.io/blog</link>
    <atom:link href="https://willis7.github.io/blog/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Mon, 29 Dec 2014 23:55:22 +0000</pubDate>
    <lastBuildDate>Mon, 29 Dec 2014 23:55:22 +0000</lastBuildDate>

    <item>
      <title>Debugging Grails tests with Intellij</title>
      <link>https://willis7.github.io/blog/blog/2014/debugging-grails-intellij.html</link>
      <pubDate>Mon, 29 Dec 2014 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/2014/debugging-grails-intellij.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I was having some real headaches with debugging my unit tests today. With the introduction of forked execution came the breakage of Intellij debugging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are some rather long winded ways of applying remote debuggers, and Ted does a great job of breaking the problem
down and &lt;a href=&quot;http://naleid.com/blog/2014/11/10/debugging-grails-forked-mode&quot;&gt;offering a solution&lt;/a&gt;. However, in my rather tiny
Grails application I was happy to sacrifice the &lt;a href=&quot;http://grails.io/post/43484836985/road-to-grails-2-3-forked-execution&quot;&gt;benefits of forked execution&lt;/a&gt; - at least for my tests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So, in BuildConfig.groovy I changed the following block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;grails.project.fork = [
    test: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256, daemon:true],
    run: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256, forkReserve:false],
    war: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256, forkReserve:false],
    console: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256]
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;grails.project.fork = [
    test: false,
    run: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256, forkReserve:false],
    war: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256, forkReserve:false],
    console: [maxMemory: 768, minMemory: 64, debug: false, maxPerm: 256]
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This change tells Grails that when we run the test configuration it shouldn&amp;#8217;t run in forked mode - this is anything we would run using the &lt;em&gt;test-app&lt;/em&gt; Grails command.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Gradle Logging - Writing the build output to a file</title>
      <link>https://willis7.github.io/blog/blog/2013/gradle-output-to-log.html</link>
      <pubDate>Thu, 17 Oct 2013 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2013/gradle-output-to-log.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This simple snippet adds 2 additional output listeners;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams&quot;&gt;Standard Out and Standard Error&lt;/a&gt;
and pipes their output to a build log.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def tstamp = new Date().format(&apos;yyyy-MM-dd_HH-mm-ss&apos;)
def buildLogDir = &quot;${rootDir}/build/logs&quot;
mkdir(&quot;${buildLogDir}&quot;)
def buildLog = new File(&quot;${buildLogDir}/${tstamp}_buildLog.log&quot;)

import org.gradle.logging.internal.*
System.setProperty(&apos;org.gradle.color.error&apos;, &apos;RED&apos;)

gradle.services.get(LoggingOutputInternal).addStandardOutputListener (new StandardOutputListener () {
    void onOutput(CharSequence output) {
        buildLog &amp;lt;&amp;lt; output
    }
})

gradle.services.get(LoggingOutputInternal).addStandardErrorListener (new StandardOutputListener () {
    void onOutput(CharSequence output) {
        buildLog &amp;lt;&amp;lt; output
    }
})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Weblogic/WLST - Packing and Unpacking a domain</title>
      <link>https://willis7.github.io/blog/blog/2012/wlst-pack-unpack-domain.html</link>
      <pubDate>Sat, 19 May 2012 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2012/wlst-pack-unpack-domain.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When you start working with distributed domains there will come a time when you need to pack the domain and unpack it in its distributed areas.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Whether you create your domain via the GUI or by scripting, all you&amp;#8217;re actually doing is creating a series of configuration files. At this point you&amp;#8217;re not actually starting any servers - that comes later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lets consider the following architecture:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;AdminServer = Machine A
Managed01   = Machine B
Managed02   = Machine C
Cluster01   = Managed01, Managed02&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So, you run through the wizard and configured the domain above. You should now notice your domain has been created on Machine A, but if you log into Machine B or C nothing exists. This is where the need to Pack and UnPack comes in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To pack the domain run the following WLST script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint python language-python&quot;&gt;&lt;code&gt;# Create a template .jar of an existing domain
# Open an existing domain

readDomain(domainDirName)

# Write the domain configuration information to a domain template
writeTemplate(templateName)

closeDomain(templateName)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This script opens the domain and extracts (as a jar) the configurations required
for the servers that will reside on Machines B and C. It&amp;#8217;s a skeleton configuration
because the Admin server information will be excluded - a domain only ever has 1
Admin server.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we have a templateName.jar we can send it to the machines that the rest
of the domain will reside on and run the unpack script on each machine:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint python language-python&quot;&gt;&lt;code&gt;# unpack.py: convert from unpack command to wlst script
# This script shows how to convert from the unpack command to a wlst script.
# Note that the domain and template values, and the options to setOption, must be single-quoted
# Specify the template that you want to use

readTemplate(&apos;c:\wls9\user_templates\wlst_wls_template.jar&apos;)

# If you specified the -username and -password option in the unpack command,
# Specify them here. Otherwise, delete these lines`
# Note that the domain_name field here is just the name of the domain, not the full path as specified in writeDomain below

cd (&apos;/Security/&amp;lt;domain-name&amp;gt;&apos;)
create (&amp;lt;user_name&amp;gt;,&apos;User&apos;)
cd (&apos;User/&amp;lt;user_name&amp;gt;&apos;)
set (&apos;Password&apos;,&amp;lt;password&amp;gt;)

# analogous to unpack -java_home
setOption(&apos;JavaHome&apos;,&amp;lt;java_home&amp;gt;)

# analogous to unpack -server_start_mode
setOption(&apos;ServerStartMode&apos;,&amp;lt;server_start_mode&amp;gt;)

# analogous to unpack -app_dir
setOption(&apos;AppDir&apos;,&amp;lt;app_dir&amp;gt;)

# write the domain
writeDomain(&amp;lt;domain&amp;gt;)

closeTemplate()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
